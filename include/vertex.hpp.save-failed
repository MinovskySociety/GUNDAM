#ifndef _VERTEX_HPP
#define _VERTEX_HPP

#include<vector>
#include<list>
#include<map>
#include<set>

enum class StoreData:bool{
      OutEdge,
    InOutEdge
};

enum class EdgeDirect:uint8_t{
    In   ,
      Out,
    InOut,/// first out then  in
    OutIn /// first  in then out
};

enum class DataStructure:bool{
    AdjacencyMatrix,
    AdjacencyList
};

enum class ContainerType:uint8_t{
    List,   /// for graph with few  elements (Edge types or associated Vertexes)
    Vector, /// for static graph
    Array,  /// for static graph that can statically set the maximum size of neighbors
    Map,    /// for graph with lots elements (Edge types or associated Vertexes)
    Set     ///
/// unimplemented feature
///,Adaptive/// use list when this node have few  elements (Edge types or associated Vertexes)
            /// use map  when this node have lots elements (Edge types or associated Vertexes)
            /// for dynamic graph with non-balanced elements distribution
};

enum class SortType:bool{
    /// how the vertexes connected by the same type of edge
    /// are sorted
    None, /// not sorted
    ByID  /// sorted by ID of the node
};

enum class IteratorType:uint8_t{
    UnspecifiedEdgeLabel,
      SpecifiedEdgeLabel
};

template<enum StoreData store_type,
         /// node
         typename   VertexIDType,
         const bool vertex_id_provided_by_user,
         typename   VertexLabelType,
         const bool vertex_has_attribute,
         typename   VertexAttributeType,
         const bool vertex_attribute_is_const,
         const bool vertex_attribute_is_dynamic,
         enum ContainerType
                    vertex_attribute_container_type,
         /// edge
         typename   EdgeIDType,
         const bool edge_id_provided_by_user,
         typename   EdgeLabelType,
         const bool edge_has_attribute,
         typename   EdgeAttributeType,
         const bool edge_attribute_is_const,
         const bool edge_attribute_is_dynamic,
         const enum ContainerType
                    edge_attribute_container_type,
         /// container
         const enum ContainerType ///  first level container type
                    edge_label_container_type,
         const enum ContainerType /// second level container type
                        vertex_container_type,
         const enum ContainerType ///  third level container type
               decomposed_edge_container_type,
         /// container sort type
         const enum SortType
                       /// the manner to sort edge label
                       /// in the edge label container
                       /// (first level container)
               edge_label_container_sort_type,
         const enum SortType /// the manner to sort vertex in
                       /// vertex container (second
                       /// level container)
                   vertex_container_sort_type,
         const enum SortType /// the manner to sort edge
                       /// in the edge container
                       /// (third level container)
          decomposed_edge_container_sort_type,
         /// miscellaneous, graph characteristics
         const bool  allow_multiple_edge,/// whether allows multiple edges between
                                   /// two nodes notices that the label
                                   /// could be different
         const bool allow_duplicate_edge,/// whether allows multiple edges with same
                                   /// label between two nodes
         typename DuplicateNumType,/// the data type to store duplicate number
         typename... AuxiliaryData>
class Vertex;
/// this class is transparent to the programmer
/// should only be configured in the construction process of graph


template</// node
         typename   VertexIDType,
         const bool vertex_id_provided_by_user,
         typename   VertexLabelType,
         const bool vertex_has_attribute,
         typename   VertexAttributeType,
         const bool vertex_attribute_is_const,
         const bool vertex_attribute_is_dynamic,
         enum ContainerType
                    vertex_attribute_container_type,
         /// edge
         typename   EdgeIDType,
         const bool edge_id_provided_by_user,
         typename   EdgeLabelType,
         const bool edge_has_attribute,
         typename   EdgeAttributeType,
         const bool edge_attribute_is_const,
         const bool edge_attribute_is_dynamic,
         const enum ContainerType
                    edge_attribute_container_type,
         /// container
         const enum ContainerType ///  first level container type
                    edge_label_container_type,
         const enum ContainerType /// second level container type
                        vertex_container_type,
         const enum ContainerType ///  third level container type
               decomposed_edge_container_type,
         /// container sort type
         const enum SortType
               edge_label_container_sort_type,
         const enum SortType
                   vertex_container_sort_type,
         const enum SortType
          decomposed_edge_container_sort_type,
         /// miscellaneous, graph characteristics
         const bool  allow_multiple_edge,
         const bool allow_duplicate_edge,
         typename DuplicateNumType,
         typename... AuxiliaryData>
class Vertex<StoreData::OutEdge,
             VertexIDType,
             vertex_id_provided_by_user,
             VertexLabelType,
             vertex_has_attribute,
             VertexAttributeType,
             vertex_attribute_is_const,
             vertex_attribute_is_dynamic,
             vertex_attribute_container_type,
             EdgeIDType,
             edge_id_provided_by_user,
             EdgeLabelType,
             edge_has_attribute,
             EdgeAttributeType,
             edge_attribute_is_const,
             edge_attribute_is_dynamic,
             edge_attribute_container_type,
                 edge_label_container_type,
                     vertex_container_type,
            decomposed_edge_container_type,
            edge_label_container_sort_type,
                vertex_container_sort_type,
       decomposed_edge_container_sort_type,
               allow_multiple_edge,
              allow_duplicate_edge,
                  DuplicateNumType,
                  AuxiliaryData...>{
private:
    static_assert(vertex_id_provided_by_user,
                  "id of vertex should provided by the user");
    static_assert(edge_id_provided_by_user,
                  "id of edge should provided by the user");

    /// if allow_duplicate_edge is true then allow_multiple_edge must be true
    static_assert(allow_duplicate_edge || !allow_multiple_edge,
                 "Illegal configuration, allows repeated edges\
                              must first allows multiple edges");
    static_assert(edge_label_container_sort_type == SortType::None,
                 "Not support edge label sorting");
    static_assert(vertex_container_sort_type == SortType::None,
                 "Not support vertex sorting");
    static_assert(decomposed_edge_container_sort_type == SortType::None,
                 "Not support edge sorting");
    /// checking container types
    /// first level container
    static_assert(edge_label_container_type != ContainerType::Set,
                 "Not support std::set as Edge Label container type,\
                    use std::map instead");
    /// second level container
    static_assert(vertex_container_type != ContainerType::Map,
                 "Not support std::map as Vertexes container type,\
                    use std::set instead");
    /// third level container
    static_assert(decomposed_edge_container_type == ContainerType::Vector,
                 "Edge container only supports std::vector yet");
    static_assert(edge_attribute_is_const,
                 "Not support variable EdgeType");

    /// a inner class that is transparent to programmers,
    /// contains the information in the vertex itself
    ///
    /// using template specification to adapt to various configurations
    ///
    /// VertexAttributeType_ decorates from VertexAttributeType
    ///     if VertexAttributeIsConst is true
    ///         then VertexAttributeType_ actually is
    ///              const VertexAttributeType
    ///     if VertexAttributeIsConst is false
    ///         then VertexAttributeType_ actually is
    ///                    VertexAttributeType
    template<bool vertex_has_attribute_,
         typename VertexAttributeType_>
    class Vertex_;

    template< typename  VertexAttributeType_>
    class Vertex_<false,VertexAttributeType_>{
    private:
        static_assert(std::is_same<VertexAttributeType_,
                                   VertexAttributeType>::value
                   || std::is_same<VertexAttributeType_,
                             const VertexAttributeType>::value,
                    "VertexAttributeType_ is illegal,\
                     should be VertexAttributeType or\
                         const VertexAttributeType");

        const VertexIDType    kID_;
        const VertexLabelType kLabel_;

    public:
        Vertex_(const    VertexIDType& id,
                const VertexLabelType& label)
                                 :kID_(id),
                               kLabel_(label){
            return;
        }
        inline const VertexIDType& id() const{
            return this->kID_;
        }
        inline const VertexLabelType& label() const{
            return this->kLabel_;
        }
    };

    template< typename  VertexAttributeType_>
    class Vertex_< true,VertexAttributeType_>:public
          Vertex_<false,VertexAttributeType_>{
    private:
        static_assert(std::is_same<VertexAttributeType_,
                                   VertexAttributeType>::value
                   || std::is_same<VertexAttributeType_,
                             const VertexAttributeType>::value,
                    "VertexAttributeType_ is illegal,\
                     should be tVertexAttributeType or\
                         const tVertexAttributeType");

        VertexAttributeType_ attribute_;

    public:
        Vertex_(const        VertexIDType&  id,
                const     VertexLabelType&  label,
                const VertexAttributeType&  attribute)
       :Vertex_<false,VertexAttributeType_>(id,label),
                                 attribute_(attribute){
            return;
        }

        inline const VertexAttributeType& attribute() const{
            return this->attribute_;
        }

        template<typename std::enable_if<!vertex_attribute_is_const>::type>
        inline void set_attribute( const  VertexAttributeType& attribute){
            this->attribute_ = attribute;
            return;
        }
    };

    /// a inner class that is transparent to programmers,
    /// contains partial information about the edge
    ///
    /// used in the CompoundVertex class
    ///
    /// using template specification to adapt to various configurations
    ///
    /// EdgeAttributeType_ decorates from EdgeAttributeType
    ///     if VertexAttributeIsConst is true
    ///         then EdgeAttributeType_ actually is
    ///              const EdgeAttributeType
    ///     if VertexAttributeIsConst is false
    ///         then EdgeAttributeType_ actually is
    ///                    EdgeAttributeType
    template<bool allow_duplicate_edge_,
             bool edge_has_attribute_,
         typename EdgeAttributeType_>
    class DecomposedEdge;

    template<typename EdgeAttributeType_>
    /// this class should not be instantiated
    class DecomposedEdge<false,false,EdgeAttributeType_>{
    /// cheat the compiler, since the parameter must be used
    /// in the class
    private:
        static_assert( std::is_object<EdgeAttributeType_>::value,
                     "this class should not be instantiated,\
                      do not have edge container in this case");
        static_assert(!std::is_object<EdgeAttributeType_>::value,
                     "this class should not be instantiated,\
                      do not have edge container in this case");
    };

    template<typename EdgeAttributeType_>
    /// not allow duplicate edge but has attribute
    /// has no ID
    class DecomposedEdge<false,true,EdgeAttributeType_>{
    private:
        static_assert( std::is_same<EdgeAttributeType_,
                                    EdgeAttributeType>::value
                    || std::is_same<EdgeAttributeType_,
                              const EdgeAttributeType>::value,
                    "EdgeAttributeType_ is illegal,\
                     should be tEdgeAttributeType or\
                         const tEdgeAttributeType");

        EdgeAttributeType_ attribute_;

    private:
        DecomposedEdge(const EdgeAttributeType& attribute)
                                    :attribute_(attribute){
            return;
        }

        inline const EdgeAttributeType& attribute() const{
            return this->attribute_;
        }

        template<typename std::enable_if<!edge_attribute_is_const>::type>
        inline void set_attribute( const  EdgeAttributeType& attribute){
            this->attribute_ = attribute;
            return;
        }
    };

    template<typename EdgeAttributeType_>
    /// allow duplicate edge and has attribute
    /// has both ID and attribute
    /// would be used in the EdgeContainer
    class DecomposedEdge< true,true,EdgeAttributeType_>:public
          DecomposedEdge<false,true,EdgeAttributeType_>{/// contains attribute
    private:
        static_assert(std::is_same<EdgeAttributeType_,
                                   EdgeAttributeType>::value
                   || std::is_same<EdgeAttributeType_,
                             const EdgeAttributeType>::value,
                    "EdgeAttributeType_ is illegal,\
                     should be EdgeAttributeType or\
                         const EdgeAttributeType");

        const EdgeIDType kID_;

    private:
        DecomposedEdge(const EdgeIDType&         id,
                       const EdgeAttributeType&  attribute)
                  :DecomposedEdge<false,true,
                             EdgeAttributeType_>(attribute),
                                            kID_(id){
            return;
        }

        inline const EdgeIDType& id() const{
            return this->kID_;
        }
    };

    template<const enum ContainerType decomposed_edge_container_type_,
             typename DecomposedEdgeType_>
    class DecomposedEdgeContainer;

    template<const enum ContainerType decomposed_edge_container_type_,
             typename DecomposedEdgeType_>
    class DecomposedEdgeContainer<decomposed_edge_container_type_,
                                  DecomposedEdgeType_>{
        /// trick the compiler, equivalent to static_assert(false)
        static_assert(decomposed_edge_container_type_ == ContainerType::Set,
                     "unsupported vertex container type");
        static_assert(decomposed_edge_container_type_ != ContainerType::Set,
                     "unsupported vertex container type");
    }

    template<typename DecomposedEdgeType_>
    class DecomposedEdgeContainer<ContainerType::Set,
                                  DecomposedEdgeType_>{
    private:
        std::set<DecomposedEdgeType_> decomposed_edges_;

    public:
        using const_iterator=std::set<DecomposedEdgeType_>::const_iterator;
        using       iterator=std::set<DecomposedEdgeType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->decomposed_edges_.cbegin();
        }
        inline const_iterator cend() const{
            return this->decomposed_edges_.cend();
        }
        inline iterator begin(){
            return this->decomposed_edges_.begin();
        }
        inline iterator end(){
            return this->decomposed_edges_.end();
        }
        inline std::pair<DecomposedEdgeType_&,bool> InsertDecomposedEdge(
                   const DecomposedEdgeType_& decomposed_edge){
            return this->decomposed_edges_.insert(decomposed_edge);
        }
    };

    template<typename DecomposedEdgeType_>
    class DecomposedEdgeContainer<ContainerType::List,
                                  DecomposedEdgeType_>{
    private:
        std::list<DecomposedEdgeType_> decomposed_edges_;

        static_assert(decomposed_edge_container_sort_type == SortType::None,
                     "other sorting type are not implemented");

    public:
        using const_iterator=std::list<DecomposedEdgeType_>::const_iterator;
        using       iterator=std::list<DecomposedEdgeType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->decomposed_edges_.cbegin();
        }
        inline const_iterator cend() const{
            return this->decomposed_edges_.cend();
        }
        inline iterator begin(){
            return this->decomposed_edges_.begin();
        }
        inline iterator end(){
            return this->decomposed_edges_.end();
        }
        inline std::pair<DecomposedEdgeType_&,bool> InsertDecomposedEdge(
                   const DecomposedEdgeType_& decomposed_edge){
            if (decomposed_edge_container_sort_type == SortType::None){
                for (const auto& it : this->decomposed_edges_)
                    if (it.id() == decomposed_edge.id())
                        return std::make_pair(it,false);
                this->decomposed_edges_.emplace_back(decomposed_edge);
                return std::make_pair(this->decomposed_edges_.back(),true);
            }
            /// other sorting type are not implemented
            assert(false);
            return std::make_pair(this->decomposed_edges_.back(),true);
        }
    };

    template<typename DecomposedEdgeType_>
    class DecomposedEdgeContainer<ContainerType::Vector,
                                  DecomposedEdgeType_>{
    private:
        std::vector<DecomposedEdgeType_> decomposed_edges_;

        static_assert(decomposed_edge_container_sort_type == SortType::None,
                     "other sorting type are not implemented");

    public:
        using const_iterator=std::vector<DecomposedEdgeType_>::const_iterator;
        using       iterator=std::vector<DecomposedEdgeType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->decomposed_edges_.cbegin();
        }
        inline const_iterator cend() const{
            return this->decomposed_edges_.cend();
        }
        inline iterator begin(){
            return this->decomposed_edges_.begin();
        }
        inline iterator end(){
            return this->decomposed_edges_.end();
        }
        inline void shrink_to_fit() const{
            this->decomposed_edges_.shrink_to_fit();
            return;
        }
        inline std::pair<DecomposedEdgeType_&,bool> InsertDecomposedEdge(
                   const DecomposedEdgeType_& decomposed_edge){
            if (decomposed_edge_container_sort_type == SortType::None){
                for (const auto& it : this->decomposed_edges_)
                    if (it.id() == decomposed_edge.id())
                        return std::make_pair(it,false);
                this->decomposed_edges_.emplace_back(decomposed_edge);
                return std::make_pair(this->decomposed_edges_.back(),true);
            }
            /// other sorting type are not implemented
            assert(false);
            return std::make_pair(this->decomposed_edges_.back(),true);
        }
    };

    template<const enum ContainerType vertex_container_type_,
             typename CompoundVertexType_>
    class VertexContainer;

    template<const enum ContainerType vertex_container_type_,
             typename CompoundVertexType_>
    class VertexContainer<vertex_container_type_,CompoundVertexType_>{
        /// trick the compiler, equivalent to static_assert(false)
        static_assert(vertex_container_type_ == ContainerType::Set,
                     "unsupported vertex container type");
        static_assert(vertex_container_type_ != ContainerType::Set,
                     "unsupported vertex container type");
    };

    template<typename CompoundVertexType_>
    class VertexContainer<ContainerType::Set,
                          CompoundVertexType_>{
    private:
        std::set<CompoundVertexType_> compound_vertexes_;

    public:
        using const_iterator=std::set<CompoundVertexType_>::const_iterator;
        using       iterator=std::set<CompoundVertexType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->compound_vertexes_.cbegin();
        }
        inline const_iterator cend() const{
            return this->compound_vertexes_.cend();
        }
        inline iterator begin(){
            return this->compound_vertexes_.begin();
        }
        inline iterator end(){
            return this->compound_vertexes_.end();
        }

        inline bool InsertCompoundVertex(
                    const CompoundVertexType_& compound_vertex){
            return this->compound_vertexes_.insert(compound_vertex).first;
        }
    };

    template<typename CompoundVertexType_>
    class VertexContainer<ContainerType::List,
                          CompoundVertexType_>{
    private:
        std::list<CompoundVertexType_> compound_vertexes_;

        static_assert(vertex_container_sort_type == SortType::None,
                     "other sorting type are not implemented");

    public:
        using const_iterator=std::list<CompoundVertexType_>::const_iterator;
        using       iterator=std::list<CompoundVertexType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->compound_vertexes_.cbegin();
        }
        inline const_iterator cend() const{
            return this->compound_vertexes_.cend();
        }
        inline iterator begin(){
            return this->compound_vertexes_.begin();
        }
        inline iterator end(){
            return this->compound_vertexes_.end();
        }

        inline std::pair<CompoundVertexType_&,bool> InsertCompoundVertex(
                   const CompoundVertexType_& compound_vertex){
            if (vertex_container_sort_type == SortType::None){
                for (const auto& it : this->compound_vertexes_)
                    if (it.id() == decomposed_edge.id())
                        return std::make_pair(it,false);
                this->compound_vertexes_.emplace_back(compound_vertex);
                return std::make_pair(this->compound_vertexes_.back(),true);
            }
            /// other sorting type are not implemented
            assert(false);
            return std::make_pair(this->compound_vertexes_.back(),true);
        }
    };

    template<typename CompoundVertexType_>
    class VertexContainer<ContainerType::Vector,
                          CompoundVertexType_>{
    private:
        std::vector<CompoundVertexType_> compound_vertexes_;

        static_assert(vertex_container_sort_type == SortType::None,
                     "other sorting type are not implemented");

    public:
        using const_iterator=std::vector<CompoundVertexType_>::const_iterator;
        using       iterator=std::vector<CompoundVertexType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->compound_vertexes_.cbegin();
        }
        inline const_iterator cend() const{
            return this->compound_vertexes_.cend();
        }
        inline iterator begin(){
            return this->compound_vertexes_.begin();
        }
        inline iterator end(){
            return this->compound_vertexes_.end();
        }
        inline void shrink_to_fit() const{
            this->compound_vertexes_.shrink_to_fit();
            return;
        }

        inline std::pair<CompoundVertexType_&,bool> InsertCompoundVertex(
                   const CompoundVertexType_& compound_vertex){
            if (vertex_container_sort_type == SortType::None){
                for (const auto& it : this->compound_vertexes_)
                    if (it.id() == decomposed_edge.id())
                        return std::make_pair(it,false);
                this->compound_vertexes_.emplace_back(compound_vertex);
                return std::make_pair(this->compound_vertexes_.back(),true);
            }
            /// other sorting type are not implemented
            assert(false);
            return std::make_pair(this->compound_vertexes_.back(),true);
        }
    };

    template<const enum ContainerType edge_label_container_type_,
             typename EdgeLabelType_,
             typename VertexContainerType_>
    class EdgeLabelContainer;

    template<const enum ContainerType edge_label_container_type,
             typename EdgeLabelType_,
             typename VertexContainerType_>
    class EdgeLabelContainer<edge_label_container_type,
                             EdgeLabelType_,VertexContainerType_>{
        /// trick the compiler, equivalent to static_assert(false)
        static_assert(edge_label_container_type == ContainerType::Set,
                     "unsupported edge label container type");
        static_assert(edge_label_container_type != ContainerType::Set,
                     "unsupported edge label container type");
    };

    template<typename EdgeLabelType_,
             typename VertexContainerType_>
    class EdgeLabelContainer<ContainerType::Map
                             EdgeLabelType_,VertexContainerType_>{
    private:
        std::map<EdgeLabelType_,VertexContainerType_> edge_labels_;

    public:
        using const_iterator=std::map<EdgeLabelType_,
                                VertexContainerType_>::const_iterator;
        using       iterator=std::map<EdgeLabelType_,
                                VertexContainerType_>::      iterator;

        inline const_iterator cbegin() const{
            return this->edge_labels_.cbegin();
        }
        inline const_iterator cend() const{
            return this->edge_labels_.cend();
        }
        inline iterator begin(){
            return this->edge_labels_.begin();
        }
        inline iterator end(){
            return this->edge_labels_.end();
        }

        inline std::pair<VertexContainerType_&,bool>
                   InsertVertexContainer(const EdgeLabelType_& edge_label){
            return this->edge_labels_.insert(
                            std::pair<EdgeLabelType_,
                                      VertexContainerType_>
                                     (edge_label,
                                      VertexContainerType_()));
        }

        inline bool HasEdgeLabel(const EdgeLabelType_& edge_label) const{
            const auto it = this->edge_labels_.find(edge_label);
            return it != this->edge_labels_.cend();
        }

        inline VertexContainerType_&
               vertex_container(const EdgeLabelType_& edge_label){
            assert(this->HasEdgeLabel(edge_label));
            auto it = this->edge_labels_.find(edge_label);
            return it->second;
        }

        inline const VertexContainerType_&
               const_vertex_container(const EdgeLabelType_& edge_label) const{
            assert(this->HasEdgeLabel(edge_label));
            const auto it = this->edge_labels_.find(edge_label);
            return it->second;
        }
    };

    template<typename EdgeLabelType_,
             typename VertexContainerType_>
    class EdgeLabelContainer<ContainerType::List
                             EdgeLabelType_,VertexContainerType_>{
    private:
        using EdgeLabelVertexContainerPair
            = std::pair<EdgeLabelType_,
                        VertexContainerType_>;

        std::list<EdgeLabelVertexContainerPair> edge_labels_;

        static_assert(edge_label_sort_type == SortType::None,
                     "other sorting type are not implemented");

    public:
        using const_iterator
            = std::list<EdgeLabelVertexContainerPair>::const_iterator;
        using       iterator
            = std::list<EdgeLabelVertexContainerPair>::      iterator;

        inline const_iterator cbegin() const{
            return this->edge_labels_.cbegin();
        }
        inline const_iterator cend() const{
            return this->edge_labels_.cend();
        }
        inline iterator begin(){
            return this->edge_labels_.begin();
        }
        inline iterator end(){
            return this->edge_labels_.end();
        }

        inline std::pair<VertexContainerType_&,bool>
                   InsertVertexContainer(const EdgeLabelType_& edge_label){
            if (edge_label_sort_type == SortType::None){
                for (auto& it : this->edge_labels_){
                    if (it.first.SameTo(edge_label)){
                        /// already exist
                        return std::make_pair(it.second,false);
                    }
                }
                /// not exist, has inserted
                this->edge_labels_.emplace_back(edge_label,
                                                VertexContainerType_());
                return std::make_pair(this->edge_labels_.back().second,
                                      true);
            }
            /// other sorting type are not implemented
            assert(false);
            return std::make_pair(this->edge_labels_.back().second,
                                  true);
        }

        inline bool HasEdgeLabel(const EdgeLabelType_& edge_label) const{
            if (edge_label_sort_type == SortType::None){
                for (const auto& it : this->edge_labels_)
                    if (it.first.SameTo(edge_label))
                        return true;
                return false;
            }
            /// other sorting type are not implemented
            assert(false);
            return false;
        }

        inline VertexContainerType_&
               vertex_container(const EdgeLabelType_& edge_label){
            assert(this->HasEdgeLabel(edge_label));
            if (edge_label_sort_type == SortType::None){
                for (auto& it : this->edge_labels_)
                    if (it.first.SameTo(edge_label))
                        return it.second;
                assert(false);
            }
            assert(false);
            return this->edge_labels_.front().second;
        }

        inline const VertexContainerType_&
               const_vertex_container(const EdgeLabelType_& edge_label) const{
            assert(this->HasEdgeLabel(edge_label));
            if (edge_label_sort_type == SortType::None){
                for (const auto& it : this->edge_labels_)
                    if (it.first.SameTo(edge_label))
                        return it.second;
                assert(false);
            }
            assert(false);
            return this->edge_labels_.front().second;
        }
    };

    template<typename EdgeLabelType_,
             typename VertexContainerType_>
    class EdgeLabelContainer<ContainerType::Vector
                             EdgeLabelType_,VertexContainerType_>{
    private:
        using EdgeLabelVertexContainerPair
            = std::pair<EdgeLabelType_,
                        VertexContainerType_>;

        std::vector<EdgeLabelVertexContainerPair> edge_labels_;

        static_assert(edge_label_sort_type == SortType::None,
                     "other sorting type are not implemented");

    public:
        using const_iterator
            = std::vector<EdgeLabelVertexContainerPair>::const_iterator;
        using       iterator
            = std::vector<EdgeLabelVertexContainerPair>::      iterator;

        inline const_iterator cbegin() const{
            return this->edge_labels_.cbegin();
        }
        inline const_iterator cend() const{
            return this->edge_labels_.cend();
        }
        inline iterator begin(){
            return this->edge_labels_.begin();
        }
        inline iterator end(){
            return this->edge_labels_.end();
        }

        inline std::pair<VertexContainerType_&,bool>
                   InsertVertexContainer(const EdgeLabelType_& edge_label){
            if (edge_label_sort_type == SortType::None){
                for (auto& it : this->edge_labels_){
                    if (it.first.SameTo(edge_label)){
                        /// already exist
                        return std::make_pair(it.second,false);
                    }
                }
                /// not exist, has inserted
                this->edge_labels_.emplace_back(edge_label,
                                                VertexContainerType_());
                return std::make_pair(this->edge_labels_.back().second,
                                      true);
            }
            /// other sorting type are not implemented
            assert(false);
            return std::make_pair(this->edge_labels_.back().second,
                                  true);
        }

        inline bool HasEdgeLabel(const EdgeLabelType_& edge_label) const{
            if (edge_label_sort_type == SortType::None){
                for (const auto& it : this->edge_labels_)
                    if (it.first.SameTo(edge_label))
                        return true;
                return false;
            }
            /// other sorting type are not implemented
            assert(false);
            return false;
        }

        inline VertexContainerType_&
               vertex_container(const EdgeLabelType_& edge_label){
            assert(this->HasEdgeLabel(edge_label));
            if (edge_label_sort_type == SortType::None){
                for (auto& it : this->edge_labels_)
                    if (it.first.SameTo(edge_label))
                        return it.second;
                assert(false);
            }
            assert(false);
            return this->edge_labels_.front().second;
        }

        inline const VertexContainerType_&
               const_vertex_container(const EdgeLabelType_& edge_label) const{
            assert(this->HasEdgeLabel(edge_label));
            if (edge_label_sort_type == SortType::None){
                for (const auto& it : this->edge_labels_)
                    if (it.first.SameTo(edge_label))
                        return it.second;
                assert(false);
            }
            assert(false);
            return this->edge_labels_.front().second;
        }
    };

    static constexpr bool
        has_decomposed_edge_container
                     = edge_has_attribute && allow_duplicate_edge;

    using VertexAttributeType_ =
    typename std::conditional<vertex_attribute_is_const,
      typename std::add_const<VertexAttributeType>::type,
                              VertexAttributeType>::type;
    using EdgeAttributeType_ =
    typename std::conditional<edge_attribute_is_const,
      typename std::add_const<EdgeAttributeType>::type,
                              EdgeAttributeType>::type;

    using InnerVertexType = Vertex_<vertex_has_attribute,
                                    VertexAttributeType>;
    using DecomposedEdgeType
        = DecomposedEdge<allow_duplicate_edge,
                         edge_has_attribute,
                         EdgeAttributeType>;

    /// stores the information of the vertex itself
    InnerVertexType vertex_;

    /// forbidden the copy construction
    Vertex(const Vertex& ) = delete;
    Vertex(const Vertex&&) = delete;
    Vertex& operator=(const Vertex& ) = delete;
    Vertex& operator=(const Vertex&&) = delete;

    /// the data sorted in each vertex can be divided into three levels
    ///  first, a container of EdgeLabels is constructed
    /// second, inside the container of each edge label,
    ///         a container of vertex is constructed to store
    ///         the vertexes connect to this vertex by the
    ///         edge with this label
    ///  third, for each vertex in the vertex container, if edge has attribute
    ///         not only stores the pointer of the target vertex,
    ///         it would also stores the rest information about the connection

    using DecomposedEdgeContainerType
        = DecomposedEdgeContainer<decomposed_edge_container_type,
                                  DecomposedEdgeType>;

    template<bool    edge_has_attribute_,
             bool  allow_duplicate_edge_,
             typename DecomposedEdgeContainerType_,
             typename DecomposedEdgeType_>
    class CompoundVertex;

    template<typename DecomposedEdgeContainerType_,
             typename DecomposedEdgeType_>
    /// edge does not have attribute and not allows duplicate edges
    /// in this case, CompoundVertex is just a trivial structure that
    /// only contains the pointer to the vertex
    class CompoundVertex<false,false,
                         DecomposedEdgeContainerType_,
                         DecomposedEdgeType_>{
    private:
        Vertex* const vertex_;

    public:
        CompoundVertex(Vertex* const vertex)
                            :vertex_(vertex){
            return;
        }
        inline Vertex* const vertex(){
            return this->vertex_;
        }
    };

    template<typename DecomposedEdgeContainerType_,
             typename DecomposedEdgeType_>
    /// edge does not have attributes but allows duplicate edges
    /// in this case, CompoundVertex contains the pointer to
    /// the vertex and a counter of duplicate cardinality
    class CompoundVertex<false,true,
                         DecomposedEdgeContainerType_,
                         DecomposedEdgeType_>
        :public CompoundVertex<false,false,
                               DecomposedEdgeContainerType_,
                               DecomposedEdgeType_>{
    private:
        DuplicateNumType duplicate_cardinality_;
        /// duplicate cardinality

    public:
        CompoundVertex(Vertex* const vertex)
        :CompoundVertex<false,false,
                 DecomposedEdgeContainerType_,
                 DecomposedEdgeType_>(vertex){
            /// initialized as only have one edge
            this->duplicate_cardinality_ = 1;
            return;
        }
        inline void AddEdge(){
            /// add an edge
            this->duplicate_cardinality_++;
            return;
        }
        inline const DuplicateNumType&
                     duplicate_cardinality() const{
            return this->duplicate_cardinality_;
        }
    };

    template<bool allow_duplicate_edge_,
         typename DecomposedEdgeContainerType_,
         typename DecomposedEdgeType_>
    /// edge has attributes
    /// whether  contain different depends on whether
    /// duplicate edges are allowed
    class CompoundVertex<true,allow_duplicate_edge_,
                         DecomposedEdgeContainerType_,
                         DecomposedEdgeType_>
               :public CompoundVertex<false,false,
                                      DecomposedEdgeContainerType_,
                                      DecomposedEdgeType_>{
    private:
        typename std::conditional<allow_duplicate_edge_,
                /// allow duplicate edges, has lots of attributes
                                  DecomposedEdgeContainerType_,
                /// not allow duplicate edges, only has one attribute
                                  DecomposedEdgeType_
                                 >::type decomposed_edge_;

    public:
        CompoundVertex(Vertex* const              vertex,
                       const DecomposedEdgeType_& decomposed_edge)
                :CompoundVertex<false,false,
                                DecomposedEdgeContainerType_,
                                DecomposedEdgeType_
                               >(vertex),
                decomposed_edge_(decomposed_edge){
            return;
        }

        template<typename std::enable_if< allow_duplicate_edge_>::type>
        inline const DecomposedEdgeContainerType_& decomposed_edge_container(){
            return this->decomposed_edge_;
        }

        template<typename std::enable_if<!allow_duplicate_edge_>::type>
        inline const DecomposedEdgeType_& decomposed_edge() const{
            return this->decomposed_edge_;
        }

        template<typename std::enable_if< allow_duplicate_edge_
            &&(decomposed_edge_container_type == ContainerType::Vector
            || decomposed_edge_container_type == ContainerType::List )>::type>
        inline DuplicateNumType AddEdge(const DecomposedEdgeType_& e){
            return this->decomposed_edge_.emplace_back(e);
        }

        template<typename std::enable_if< allow_duplicate_edge_
            && decomposed_edge_container_type == ContainerType::Set   >::type>
        inline DuplicateNumType AddEdge(const DecomposedEdgeType_& e){
            return this->decomposed_edge_.insert(e);
        }

        template<typename std::enable_if< allow_duplicate_edge_>::type>
        inline DuplicateNumType duplicate_cardinality() const{
            return this->decomposed_edge_.size();
        }
    };

    using CompoundVertexType = CompoundVertex<edge_has_attribute,
                                            allow_duplicate_edge,
                                     DecomposedEdgeContainerType,
                                     DecomposedEdgeType>;

    using VertexContainerType
        = VertexContainer<vertex_container_type,CompoundVertexType>;

    using EdgeLabelContainerType
        = EdgeLabelContainer<edge_label_container_type,
                             EdgeLabelType,
                             VertexContainerType>;

    EdgeLabelContainerType out_edges_;

    /// iterator of the first level container
    template<constexpr bool is_const_>
    class EdgeLabelIterator;
    /// iterator of the second level container
    template<constexpr enum IteratorType iterator_type_,
             constexpr bool is_const_>
    class VertexIterator;
    /// iterator of the third level container
    template<constexpr enum IteratorType iterator_type_,
             constexpr bool has_decomposed_edge_container_,
             constexpr bool is_const_>
    class EdgeIterator;/// a inner class, transparent
                       /// to the programmer

    /// iterator of the first level container
    template<constexpr bool is_const_>
    class EdgeLabelIterator{
    /// return all the edge labels
    /// iterator on the first level storage
    private:
        typename std::conditional<is_const_,
              typename EdgeLabelContainerType::const_iterator,
              typename EdgeLabelContainerType::      iterator
                                                      >::type iterator_;

        const typename EdgeLabelContainerType::const_iterator kEndIter_;

        using EdgeLabelContainerType_ =
            typename std::conditional<is_const_,
              typename std::add_const<EdgeLabelContainerType>::type,
                                      EdgeLabelContainerType>::type;

    protected:
        inline const VertexContainerType& const_vertex_container() const{
            assert(!this->IsDone());
            return this->iterator_->second;
        }

        template<constexpr bool judge = is_const_,/// trick the compiler
                 typename std::enable_if<!judge>::type>
        inline VertexContainerType& vertex_container(){
            static_assert(judge == is_const_,
                         "illegal usage of this method");
            assert(!this->IsDone());
            return this->iterator_->second;
        }

    public:
        template<typename std::enable_if< is_const_>::type>
        EdgeLabelIterator(
                  EdgeLabelContainerType_& edge_label_container)
                               :iterator_( edge_label_container.cbegin()),
                                kEndIter_( edge_label_container.cend  ()){
            assert(!this->IsDone());/// should not be empty
            return;
        }

        template<typename std::enable_if<!is_const_>::type>
        EdgeLabelIterator(
                  EdgeLabelContainerType_& edge_label_container)
                               :iterator_( edge_label_container. begin()),
                                kEndIter_( edge_label_container.cend  ()){
            assert(!this->IsDone());/// should not be empty
            return;
        }

        inline const EdgeLabelType& operator*() const{
            assert(!this->IsDone());
            return this->iterator_->first;
        }

        inline EdgeLabelIterator operator++ (){
            ///prefix
            assert(!this->IsDone());
            this->iterator_++;
            return EdgeLabelIterator(*this);
        }

        inline EdgeLabelIterator operator++ (int){
            ///postfix
            assert(!this->IsDone());
            EdgeLabelIterator temp(*this);
            this->iterator_++;
            return temp;
        }

        inline bool IsDone() const{
            return this->iterator_ == this->kEndIter_;
        }
    };

    template<constexpr bool is_const_>
    class VertexIterator<IteratorType::  SpecifiedEdgeLabel,is_const_>{
    /// return all the vertexes connected to this vertex
    /// that satisfies some certain restrictions
    ///
    /// the iterator on the second level storage
    /// it can use the first level iterator to reuse the code
    private:
        typename std::conditional<is_const_,
            typename VertexContainerType::const_iterator,
            typename VertexContainerType::      iterator>::type iterator_;

        const typename VertexContainerType::const_iterator kEndIter_;

        class GetIteratorConst_{
        public:
            inline static typename VertexContainerType::const_iterator begin(
                             const VertexContainerType& vertex_container){
                return vertex_container.cbegin();
            }
        };

        class GetIterator_{
        public:
            inline typename VertexContainerType::iterator begin(
                            VertexContainerType& vertex_container){
                return vertex_container.begin();
            }
        };

        /// similar to "functional object"
        using GetIterator_ = typename std::conditional<is_const_,
                                                       GetIteratorConst_,
                                                       GetIterator_>::type;

        using VertexContainerType_ =
            typename std::conditional<is_const_,
                typename std::add_const<VertexContainerType>::type,
                                        VertexContainerType>::type;

    protected:
        inline const CompoundVertexType& const_compound_vertex() const{
            assert(!this->IsDone());
            return *(this->iterator_);
        }

        template<constexpr bool judge = is_const_,
                 typename std::enable_if<!judge>::type>
        inline CompoundVertexType& compound_vertex(){
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            assert(!this->IsDone());
            return *(this->iterator_);
        }

        inline void ToNext(){
            ++(*this);
            return;
        }

    public:
        VertexIterator(VertexContainerType_& vertex_container)
             :iterator_(GetIterator_::begin( vertex_container)),
                                  kEndIter_( vertex_container.cend()){
            return;
        }

        /// override the "->" operation to access the method of vertex
        /// wenzhi: not sure whether it works this way
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<judge>::type>
        inline const Vertex* const operator->() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            return this->iterator_->vertex();
        }
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<!judge>::type>
        inline       Vertex* const operator->() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            return this->iterator_->vertex();
        }

        inline VertexIterator operator++ (){
            ///prefix
            this->iterator_++;
            return VertexIterator(*this);
        }

        inline VertexIterator operator++ (int){
            ///postfix
            VertexIterator temp(*this);
            this->iterator_++;
            return temp;
        }

        inline bool IsDone() const{
            return this->iterator_ == this->kEndIter_;
        }
    };

    template<bool is_const_>
    class VertexIterator<IteratorType::UnspecifiedEdgeLabel,is_const_>
     :protected EdgeLabelIterator<is_const_>{
    /// return all the vertexes connected to this vertex
    /// that satisfies some certain restrictions
    ///
    /// the iterator on the second level storage
    /// it can use the first level iterator to reuse the code
    private:
        typename std::conditional<is_const_,
              typename VertexContainerType::const_iterator,
              typename VertexContainerType::      iterator>::type iterator_;

        using EdgeLabelIteratorType = EdgeLabelIterator<is_const_>;

        using EdgeLabelContainerType_ =
            typename std::conditional<is_const_,
              typename std::add_const<EdgeLabelContainerType>::type,
                                      EdgeLabelContainerType>::type;

        /// wenzhi: not sure whether this way works
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<judge>::type>
        inline typename VertexContainerType::const_iterator
                                                  iterator_begin() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            return EdgeLabelIteratorType::const_vertex_container()
                                                         .cbegin();
        }
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<!judge>::type>
        inline typename VertexContainerType::iterator
                                            iterator_begin() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            return EdgeLabelIteratorType::vertex_container()
                                                    .begin();
        }

    protected:
        inline const CompoundVertexType& const_compound_vertex() const{
            assert(!this->IsDone());
            return *(this->iterator_);
        }
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<!judge>::type>
        inline CompoundVertexType& compound_vertex(){
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            assert(!this->IsDone());
            return *(this->iterator_);
        }
        inline void ToNext(){
            ++(*this);
            return;
        }

    public:
        template<typename std::enable_if< is_const_>::type>
        VertexIterator(EdgeLabelContainerType_& edge_label_container)
                      :EdgeLabelIteratorType   (edge_label_container){
            assert(!this->IsDone());/// should not be empty
            this->iterator_ = EdgeLabelIteratorType::const_vertex_container()
                                                                    .cbegin();
            return;
        }

        template<typename std::enable_if<!is_const_>::type>
        VertexIterator(EdgeLabelContainerType_& edge_label_container)
                      :EdgeLabelIteratorType   (edge_label_container){
            assert(!this->IsDone());/// should not be empty
            this->iterator_ = EdgeLabelIteratorType::vertex_container()
                                                               .begin();
            return;
        }

        /// override the "->" operation to access the method of vertex
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<judge>::type>
        inline const Vertex* const operator->() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            assert(!this->IsDone());
            return this->iterator_->vertex();
        }
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<judge>::type>
        inline const Vertex& operator*() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            assert(!this->IsDone());
            return *(this->iterator_->vertex());
        }

        template<constexpr bool judge = is_const_,
                 typename std::enable_if<!judge>::type>
        inline Vertex* const operator->() const{
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            assert(!this->IsDone());
            return this->iterator_->vertex();
        }
        template<constexpr bool judge = is_const_,
                 typename std::enable_if<!judge>::type>
        inline Vertex& operator*(){
            static_assert(judge == is_const_,
                         "Illegal usage of this method");
            assert(!this->IsDone());
            return *(this->iterator_->vertex());
        }

        inline VertexIterator operator++ (){
            ///prefix
            assert(!this->IsDone());
            this->iterator_++;
            if (this->iterator_
             != EdgeLabelIteratorType::const_vertex_container().cend()){
                /// has not visited all edges with this edge label
                return VertexIterator(*this);
            }
            /// has already visited all edges with this edge label
            EdgeLabelIteratorType::ToNext();/// to check whether it is illegal
            if (EdgeLabelIteratorType::IsDone()){
                /// has visited all edge label
                assert(this->IsDone());
                return;
            }
            this->iterator_ = this->iterator_begin();
        }

        inline VertexIterator operator++ (int){
            ///postfix
            VertexIterator temp(*this);
            ++(*this);
            return temp;
        }

        inline bool IsDone() const{
            return EdgeLabelIteratorType::IsDone();
        }
    };

    /// not specify any thing, just return all vertexes
    /// with specifies edge label
    /// with specifies edge label and

    /// iterator of the third level container
    template<enum IteratorType iterator_type_,
             bool is_const_>
    class EdgeIterator<iterator_type_,false,is_const_>
       :protected VertexIterator<iterator_type_,is_const_>{
    /// does not actually has a container for edge in this case
    ///
    /// return all the vertexes connected to this vertex under
    /// some certain restrictions
    ///
    /// the iterator on the second level storage
    /// it can use the iterators on the above two levels to reuse the code
    private:
        using VertexContainerType_ =
            typename std::conditional<is_const_,
              typename std::add_const<VertexContainerType>::type,
                                      VertexContainerType>::type;
        using EdgeLabelContainerType_ =
            typename std::conditional<is_const_,
              typename std::add_const<EdgeLabelContainerType>::type,
                                      EdgeLabelContainerType>::type;

        using VertexIteratorType = VertexIterator<iterator_type_,
                                                       is_const_>;

        const Vertex* const  kSrcVertex_;
        const EdgeLabelType& kEdgeLabel_;

    public:
        template<typename std::enable_if<
                 iterator_type_ == IteratorType::  SpecifiedEdgeLabel>::type>
        EdgeIterator(VertexContainerType_& vertex_container,
                     const Vertex* const   src_vertex,
                     const EdgeLabelType&  edge_label)
                       :VertexIteratorType(vertex_container),
                               kSrcVertex_(src_vertex),
                               kEdgeLabel_(edge_label){
            return;
        }

        template<typename std::enable_if<
                iterator_type_ == IteratorType::UnspecifiedEdgeLabel>::type>
        EdgeIterator(EdgeLabelContainerType_& edge_label_container,
                     const Vertex* const      src_vertex,
                     const EdgeLabelType&     edge_label)
                          :VertexIteratorType(edge_label_container),
                                  kSrcVertex_(src_vertex),
                                  kEdgeLabel_(edge_label){
            return;
        }

        inline const Vertex* const src() const{
            assert(!this->IsDone());
            return this->kSrcVertex_;
        }

        inline const Vertex* const dst() const{
            assert(!this->IsDone());
            return VertexIteratorType::compound_vertex()
                                               .vertex();
        }

        inline const EdgeLabelType& label() const{
            assert(!this->IsDone());
            return this->kEdgeLabel_;
        }

        template<bool judge = !allow_duplicate_edge
                            && edge_has_attribute
                            && is_const_,
                 typename std::enable_if<judge>::type>
        inline const EdgeAttributeType& const_attribute() const{
            static_assert(judge = !allow_duplicate_edge
                                && edge_has_attribute
                                && is_const_,
                         "illegal usage of this method");
            assert(!this->IsDone());
            return  VertexIteratorType::compound_vertex()
                                       .decomposed_edge()
                                       .attribute();
        }

        template<bool judge = !allow_duplicate_edge
                            && edge_has_attribute
                            &&!is_const_,
                 typename std::enable_if<judge>::type>
        inline EdgeAttributeType& attribute(){
            static_assert(judge = !allow_duplicate_edge
                                && edge_has_attribute
                                &&!is_const_,
                         "illegal usage of this method");
            assert(!this->IsDone());
            return  VertexIteratorType::compound_vertex()
                                       .decomposed_edge()
                                       .attribute();
        }

        template<bool judge = allow_duplicate_edge
                           &&!edge_has_attribute,
                 typename std::enable_if<judge>::type>
        inline const DuplicateNumType& duplicate_cardinality(){
            assert(!this->IsDone());
            return VertexIteratorType::compound_vertex()
                                      .duplicate_cardinality();
        }

        inline EdgeIterator operator++(){
            ///prefix
            VertexIteratorType::ToNext();
            return (*this);
        }

        inline EdgeIterator operator++(int){
            ///postfix
            EdgeIterator temp(*this);
            ++(*this);
            return temp;
        }
    };

    template<enum IteratorType iterator_type_,
             const bool is_const_>
    class EdgeIterator<iterator_type_,true,is_const_>
       :protected VertexIterator<iterator_type_,is_const_>{
    /// return all the vertexes connected to this vertex under
    /// some certain restrictions
    ///
    /// the iterator on the second level storage
    /// it can use the iterators on the above two levels to reuse the code
    private:
        using VertexContainerType_ =
            typename std::conditional<is_const_,
              typename std::add_const<VertexContainerType>::type,
                                      VertexContainerType>::type;
        using EdgeLabelContainerType_ =
            typename std::conditional<is_const_,
              typename std::add_const<EdgeLabelContainerType>::type,
                                      EdgeLabelContainerType>::type;

        using VertexPtr
            = typename std::conditional<is_const_,
                             const Vertex* const,
                                   Vertex* const>::type;

        using VertexIteratorType = VertexIterator<iterator_type_,is_const_>;

        VertexPtr            kSrcVertex_;
        const EdgeLabelType& kEdgeLabel_;

        typename std::conditional<is_const_,
                typename DecomposedEdgeContainerType::const_iterator,
                typename DecomposedEdgeContainerType::      iterator
                                                             >::type iterator_;

        template<typename std::enable_if<is_const_>::type>
        inline typename DecomposedEdgeContainerType::const_iterator
                                                     iterator_begin() const{
            return VertexIteratorType::compound_vertex()
                                      .decomposed_edge_container()
                                      .cbegin();
        }
        template<typename std::enable_if<!is_const_>::type>
        inline typename DecomposedEdgeContainerType::iterator
                                                     iterator_begin() const{
            return VertexIteratorType::compound_vertex()
                                      .decomposed_edge_container()
                                      .begin();
        }

    public:
        template<typename std::enable_if<
                 iterator_type_ == IteratorType::  SpecifiedEdgeLabel>::type>
        EdgeIterator(VertexContainerType_& vertex_container,
                     VertexPtr             src_vertex,
                     const EdgeLabelType&  edge_label)
                       :VertexIteratorType(vertex_container),
                               kSrcVertex_(src_vertex),
                               kEdgeLabel_(edge_label),
                                 iterator_(this->iterator_begin()){
            return;
        }

        template<typename std::enable_if<
                iterator_type_ == IteratorType::UnspecifiedEdgeLabel>::type>
        EdgeIterator(EdgeLabelContainerType_& edge_label_container,
                     VertexPtr                src_vertex,
                     const EdgeLabelType&     edge_label)
                          :VertexIteratorType(edge_label_container),
                                  kSrcVertex_(src_vertex),
                                  kEdgeLabel_(edge_label),
                                    iterator_(this->iterator_begin()){
            return;
        }

        inline VertexPtr src() const{
            assert(!this->IsDone());
            return this->kSrcVertex_;
        }
        inline VertexPtr dst() const{
            assert(!this->IsDone());
            return VertexIteratorType::compound_vertex()
                                               .vertex();
        }
        inline const EdgeLabelType& label() const{
            assert(!this->IsDone());
            return this->kEdgeLabel_;
        }

        template<typename std::enable_if< is_const_>::type>
        inline const EdgeAttributeType& attribute() const{
            assert(!this->IsDone());
            return this->decomposed_edge_iterator_->attribute();
        }
        template<typename std::enable_if<!is_const_>::type>
        inline EdgeAttributeType& attribute(){
            assert(!this->IsDone());
            return this->decomposed_edge_iterator_->attribute();
        }

        inline const DuplicateNumType& duplicate_cardinality() const{
            assert(!this->IsDone());
            return this->decomposed_edge_iterator_
                       ->duplicate_cardinality().size();
        }

        inline bool IsDone() const{
            /// has visited all decomposed edge container
            return VertexIteratorType::IsDone();
        }

        inline EdgeIterator operator++(){
            ///prefix
            assert(!this->IsDone());
            this->decomposed_edge_iterator_++;
            if (this->decomposed_edge_iterator_
             != VertexIteratorType::compound_vertex()
                                   .decomposed_edge_container().cend()){
                /// has not visited all elements
                /// in this container of decomposed edge
                return;
            }
            /// has visited all elements in this
            /// decomposed_edge_container
            VertexIteratorType::ToNext();
            if (!VertexIteratorType::IsDone()){
                /// has already visited all elements
                /// in this container of decomposed edge
                assert(this->IsDone());
                return;
            }
            /// visits the next decomposed_edge_container
            /// the next decomposed_edge_container should not be empty
            assert(VertexIteratorType::compound_vertex()
                                      .decomposed_edge_container().cbegin()
                != VertexIteratorType::compound_vertex()
                                      .decomposed_edge_container().cend  ());
            this->decomposed_edge_iterator_ = this->iterator_begin();
            return (*this);
        }
        inline EdgeIterator operator++(int){
            ///postfix
            assert(!this->IsDone());
            EdgeIterator temp(*this);
            ++(*this);
            return temp;
        }
    };

public:
    /// another name of EdgeLabelIterator
    using const_edge_label_iterator = EdgeLabelIterator<true>;
    /// alias template of VertexIterator
    template<enum IteratorType iterator_type_>
    using       vertex_iterator = VertexIterator<iterator_type_,false>;
    template<enum IteratorType iterator_type_>
    using const_vertex_iterator = VertexIterator<iterator_type_,true >;
    /// alias template of EdgeIterator
    template<enum IteratorType iterator_type_>
    using       edge_iterator = EdgeIterator<iterator_type_,
                                             has_decomposed_edge_container,
                                             false>;
    template<enum IteratorType iterator_type_>
    using const_edge_iterator = EdgeIterator<iterator_type_,
                                             has_decomposed_edge_container,
                                             true >;

    template<class... Args>
    Vertex(const Args&... args):vertex_(args...){
        return;
    }

    inline const VertexIDType& id() const{
        return this->vertex_.id();
    }

    inline const VertexLabelType& label() const{
        return this->vertex_.label();
    }

    template<bool determine = vertex_has_attribute,
             typename std::enable_if<determine,bool>::type=true>
    inline const VertexAttributeType& const_attribute() const{
        static_assert(determine == vertex_has_attribute,
                     "illegal usage of this method, stated as template class\
                      just to trick the compiler");
        return this->vertex_.attribute();
    }

    template<bool determine = vertex_has_attribute
                           &&!vertex_attribute_is_const,
             typename std::enable_if<determine,bool>::type=true>
    inline VertexAttributeType& attribute(){
        static_assert(determine == vertex_has_attribute
                                &&!vertex_attribute_is_const,
                     "illegal usage of this method, stated as template class\
                      just to trick the compiler");
        return this->vertex_.attribute();
    }

private:

    using decomposed_edge_container

    template<enum ContainerType edge_label_container_type_>
    class VertexContainer_;

    template

    template<>
    class vertex_container_<ContainerType::Map>{
    public:
        static inline VertexContainerType& get(
                      const EdgeLabelType& edge_label,
                      const EdgeLabelContainerType& edge_label_container){
            return;
        }
    };

    using vertex_container = vertex_container_<edge_label_container_type>;

    template<bool determine =(edge_label_container_type
                           == ContainerType::Map),
             typename std::enable_if<determine,bool>::type=true>
    inline VertexContainerType& vertex_container(
           const EdgeLabelType& edge_label){
        static_assert(determine ==(edge_label_container_type
                                == ContainerType::Map),
                     "illegal usage of this method, stated as template class\
                      just to trick the compiler");
        assert(this->HasEdgeLabel(edge_label));
        return this->out_edges_.find(edge_label)->second;
    }

    template<bool determine=(edge_label_container_type==ContainerType::List
                          || edge_label_container_type==ContainerType::Vector),
             typename std::enable_if<determine,bool>::type=true>
    inline VertexContainerType& vertex_container(
           const EdgeLabelType& edge_label){
        static_assert(determine
                    ==(edge_label_container_type == ContainerType::List
                    || edge_label_container_type == ContainerType::Vector),
                     "illegal usage of this method, stated as template class\
                      just to trick the compiler");
        assert(this->HasEdgeLabel(edge_label));
        for (const auto& it : this->out_edges_)
            if (it.first == edge_label)
                return it.second;
        assert(false);
        return this->out_edges_.begin()->second;
    }

    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::Map>::type>
    inline const VertexContainerType& const_vertex_container(
                 const EdgeLabelType& edge_label) const{
        assert(this->HasEdgeLabel(edge_label));
        return this->out_edges_.find(edge_label)->second;
    }

    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::List
               || edge_label_container_type == ContainerType::Vector>::type>
    inline const VertexContainerType& const_vertex_container(
                 const EdgeLabelType& edge_label) const{
        assert(this->HasEdgeLabel(edge_label));
        for (const auto& it : this->out_edges_)
            if (it.first == edge_label)
                return it.second;
        assert(false);
        return this->out_edges_.cbegin()->second;
    }

    /// operate on the first level container
    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::List
               || edge_label_container_type == ContainerType::Vector>::type>
    inline VertexContainerType&
     InsertVertexContainer(const EdgeLabelType& edge_label){
        /// if the CompoundVertex has already exist
        /// then return false and set the insertedVertex
        /// to the address of the compound vertex
        ///
        /// if the CompoundVertex does not exist
        /// then return true, and insert the CompoundVertex
        /// to the container and set the insertedVertex to
        /// nullptr
        for (const auto& it : this->out_edges_)
            if (it.first.SameTo(edge_label)){
                /// found it
                return it.second;
            }
        /// not found
        this->out_edges_.emplace_back(std::make_pair(edge_label,
                                            VertexContainerType()));
        return this->out_edges_.last()->second;
    }

    /// operate on the first level container
    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::Map>::type>
    inline VertexContainerType&
     InsertVertexContainer(const EdgeLabelType& edge_label){
        return this->out_edges_.insert(std::make_pair(edge_label,
                                             VertexContainerType()))->second;
    }

    /// operate on the second level container
    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::List
               || edge_label_container_type == ContainerType::Vector>::type>
    inline bool InsertCompoundVertex(
                        const EdgeLabelType&            edge_label,
                        const CompoundVertexType&  compound_vertex,
                              CompoundVertexType*& inserted_vertex){
        /** if compound_vertex has already exist in the container
         *  then return false and set the insertedVertex
         *  to the address of the compound vertex
         *  if compound_vertex does not exist
         *  then return true, and insert the CompoundVertex
         *  to the container and set the inserted_vertex to
         *  the already exist CompoundVertex
        **/
        /// get the target vertex container
        VertexContainerType&  target_vertex_container
            = this->InsertVertexContainer(edge_label);
        /// restriction of the input
        assert(inserted_vertex == nullptr);
        /// insert the given compound_vertex
        for (const auto& it : target_vertex_container){
            if (it.first.SameTo(compound_vertex)){
                /// already exist
                inserted_vertex = &it;
                return false;/// not inserted
            }
        }
        /// not exist
        target_vertex_container.emplace_back(compound_vertex);
        inserted_vertex = &(target_vertex_container.last());
        return true;/// inserted
    }

    /// operate on the second level container
    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::Set>::type>
    inline bool InsertCompoundVertex(
                            const EdgeLabelType&            edge_label,
                            const CompoundVertexType&  compound_vertex,
                                  CompoundVertexType*& inserted_vertex){
        /** if compound_vertex has already exist in the container
         *  then return false and set the insertedVertex
         *  to the address of the compound vertex
         *  if compound_vertex does not exist
         *  then return true, and insert the CompoundVertex
         *  to the container and set the inserted_vertex to
         *  the already exist CompoundVertex
        **/
        /// get the target vertex container
        VertexContainerType& target_vertex_container
            = this->InsertVertexContainer(edge_label);
        /// restriction of the input
        assert(inserted_vertex == nullptr);
        /// insert the given compound_vertex
        std::pair<typename VertexContainerType::iterator,bool>
               ret = target_vertex_container.insert(compound_vertex);
        inserted_vertex = ret.first;
        return ret.second;
    }

public:
    /// return the iterator of the first level container
    /// only have const iterator
    inline const_edge_label_iterator edge_label_cbegin() const{
        /// visit all edge labels
        return
           const_edge_label_iterator(this->out_edges_);
    }

    /// return the iterator of the vertex container with all edge label
    /// constant iterator
    inline const_vertex_iterator<IteratorType::UnspecifiedEdgeLabel>
                 vertex_cbegin() const{
        /// visit the vertexes connected with all edge labels
        return
           const_vertex_iterator<IteratorType::UnspecifiedEdgeLabel>
                                               (this->out_edges_);
    }
    /// non-constant iterator
    inline vertex_iterator<IteratorType::UnspecifiedEdgeLabel>
           vertex_begin(){
        /// visit the vertexes connected with all edge labels
        return
           vertex_iterator<IteratorType::UnspecifiedEdgeLabel>
                                         (this->out_edges_);
    }

    /// return the iterator of the vertex container with specified edge label
    /// constant iterator
    inline const_vertex_iterator<IteratorType::SpecifiedEdgeLabel>
                 vertex_cbegin(const EdgeLabelType& edge_label) const{
        /// visit the vertexes connected with specified edge label
        return
           const_vertex_iterator<IteratorType::SpecifiedEdgeLabel>
               (this->const_vertex_container(edge_label));
    }
    /// non-constant iterator
    inline vertex_iterator<IteratorType::SpecifiedEdgeLabel>
           vertex_begin(const EdgeLabelType& edge_label){
        /// visit the vertexes connected with specified edge label
        return
           vertex_iterator<IteratorType::SpecifiedEdgeLabel>
               (this->vertex_container(edge_label));
    }

    /// return the iterator of the third level container
    /// with specified edge label
    /// constant iterator
    inline const_edge_iterator<IteratorType::SpecifiedEdgeLabel>
                 edge_cbegin(const EdgeLabelType& edge_label) const{
        /// visit the vertexes connected with specified edge label
        return
           const_edge_iterator<IteratorType::SpecifiedEdgeLabel>
               (this->const_vertex_container(edge_label));
    }
    /// non-constant iterator
    inline edge_iterator<IteratorType::SpecifiedEdgeLabel>
           edge_begin(const EdgeLabelType& edge_label){
        /// visit the vertexes connected with specified edge label
        return
           edge_iterator<IteratorType::SpecifiedEdgeLabel>
               (this->vertex_container(edge_label));
    }

    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::Map>::type>
    inline bool HasEdgeLabel(const EdgeLabelType& edge_label) const{
        return this->out_edges_.find(edge_label)
            != this->out_edges_.cend();
    }

    template<typename std::enable_if<
                  edge_label_container_type == ContainerType::List
               || edge_label_container_type == ContainerType::Vector>::type>
    inline bool HasEdgeLabel(const EdgeLabelType& edge_label) const{
        for (const auto& it : this->out_edges_)
            if (it.first.SameTo(edge_label))
                return true;
        return false;
    }

    /// operate on the third level container
    template<typename std::enable_if<!edge_has_attribute>::type>
    inline void AddEdge(const Vertex* const vertex,
                        const EdgeLabelType& edge_label){
        /// add an directed edge, from "this" to "vertex"
        static_assert(!has_decomposed_edge_container,
                     "Illegal configuration, should not \
                      have decomposed edge since there are no attribute");
        /// not allow duplicate edges
        CompoundVertexType* inserted_vertex = nullptr;
        if (this->InsertCompoundVertex(edge_label,
                       CompoundVertexType(vertex),
                                 inserted_vertex)){
            /// not exist exists, has inserted
            assert(inserted_vertex!=nullptr);
            assert(inserted_vertex->duplicate_cardinality() == 1);
            return;
        }
        /// already exists, should allow duplicate edge
        assert(allow_duplicate_edge);
        assert(inserted_vertex!=nullptr);
        inserted_vertex->AddEdge();
        return;
    }

    /// operate on the third level container
    template<typename std::enable_if<edge_has_attribute>::type>
    inline void AddEdge(const Vertex* const vertex,
                        const EdgeLabelType&     edge_label,
                        const EdgeIDType&        edge_id,
                        const EdgeAttributeType& edge_attribute){
        /// add an directed edge, from "this" to "vertex"
        static_assert(!has_decomposed_edge_container,
                     "Illegal configuration, should not \
                      have decomposed edge since there are no attribute");
        /// has attribute but not allow duplicate edges
        CompoundVertexType* inserted_vertex = nullptr;
        if (this->InsertCompoundVertex(edge_label,
                                       CompoundVertexType(vertex,
                                                          edge_attribute),
                                       inserted_vertex)){
            /// not exists, has been inserted
            assert(inserted_vertex!=nullptr);
            assert(inserted_vertex->duplicate_cardinality() == 1);
            return;
        }
        /// already exists
        /// should have container for decomposed edge
        assert(has_decomposed_edge_container);
        assert(inserted_vertex!=nullptr);
        inserted_vertex->AddEdge(edge_id,edge_attribute);
        return;
    }
};

//template<typename... configures>
//Vertex<StoreData::InOutEdge,
//       configures...>:public Vertex<StoreData::OutEdge,
//                                    configures...>{
//private:
//    using OutVertexType = Vertex<StoreData::OutEdge,
//                                 configures...>::EdgeTypeDataType;
//
//    EdgeTypeDataType in_edges_;
//
//public:
//    using OutVertexType::Vertex;
//
//    template<enum class EdgeDirect direct,
//           typename std::enable_if<direct == EdgeDirect::In, int>::type=0>
//    inline VertexIterator<EdgeDirect::In   > GetIterator() const{
//        return VertexIterator<false,EdgeDirect::In>(this->inEdges_);
//    }
//    template<enum class EdgeDirect direct,
//           typename std::enable_if<direct == EdgeDirect::InOut, int>::type=0>
//    inline VertexIterator<EdgeDirect::InOut> GetIterator() const{
//        return VertexIterator<true,EdgeDirect::InOut>(this-> inEdges_,
//                                                      this->out_edges_);
//    }
//    template<enum class EdgeDirect direct,
//           typename std::enable_if<direct == EdgeDirect::OutIn, int>::type=0>
//    inline VertexIterator<EdgeDirect::OutIn> GetIterator() const{
//        return VertexIterator<true,EdgeDirect::OutIn>(this->out_edges_,
//                                                      this-> inEdges_);
//    }
//
//}

//template<size_t D, size_t E>
//class Field {
//    template<size_t, size_t> struct Field_Members {
//        int _projection;
//    };
//    template<size_t V> struct Field_Members<V, V> { };
//    Field_Members<D, E> m;
//};
//
//
//    template<enum class EdgeDirect>
//    class VertexesIterator;
//
//    template<enum class EdgeDirect direct,
//             typename std::enable_if<direct == EdgeDirect::In
//                                  || direct == EdgeDirect::Out, int>::type=0>
//    class VertexesIterator{
//    private:
//              VertexesContainerType::const_i terator  vertexesIter_;
//              EdgeTypeContainerType::const_iterator  edgeTypeIter_;
//        const EdgeTypeContainerType::const_iterator kEdgeTypeIterEnd_;
//
//    public:
//        VertexesIterator(const EdgeTypeDataType& edgeType)
//                             : edgeTypeIter_   ( edgeType.cbegin()),
//                              kEdgeTypeIterEnd_( edgeType.cend  ()){
//            if (edgeType.cbegin()
//             == edgeType.cend  ()){
//                /// could happen, when this vertex does not have in/out edges
//                assert(this->IsDone());
//                /// ToDo by Wenzhi:
//                ///     add a proporal initialization for this->vertexesIter_;
//                return;
//            }
//            /// if there is a type of edge, then it must be not empty
//            assert(this->edgeTypeIter_.cbegin()
//                != this->edgeTypeIter_.  cend());
//            this->vertexesIter_ = this->edgeTypeIter_->cbegin();
//            return;
//        }
//
//        inline bool IsDone() const{
//            return this-> edgeTypeIter_
//                == this->kEdgeTypeIterEnd_;
//        }
//
//        inline const Vertex* const operator*() const{
//            assert(!this->IsDone());
//            return *(this->vertexesIter_);
//        }
//
//        inline const Vertex* const GetVertex() const{
//            assert(!this->IsDone());
//            return  *this->vertexesIter_;
//        }
//
//        inline const EdgeType& GetEdgeType() const{
//            return (*this->edgeTypeIter_).first;
//        }
//
//        inline void ToNext() {
//            assert(!this->IsDone());
//            this->vertexesIter_++;/// the next vertex in this type of edge
//            if (this->vertexesIter_ != this->edgeTypeIter_.cend()){
//                /// has not enumerated all vertex in this type of edge
//                return
//            }
//            /// has enumerated all vertex in this type of edge
//            assert(this->vertexesIter_ == this->edgeTypeIter_.cend());
//            this->edgeTypeIter_++;/// change to another type
//            if (this->IsDone())
//                return;/// has visited all types of edge
//            /// begins to enumerate the next type of edge
//            this->vertexesIter_ = this->edgeTypeIter_.cbegin();
//            return;
//        }
//    };
//
//    template<enum class EdgeDirect>
//    class EdgeTypeIterator;
//
//    template<enum class EdgeDirect direct,
//             typename std::enable_if<direct == EdgeDirect::In
//                                  || direct == EdgeDirect::Out, int>::type=0>
//    class EdgeTypeIterator{
//    private:
//              EdgeTypeContainerType::const_iterator  edgeTypeIter_;
//        const EdgeTypeContainerType::const_iterator kEdgeTypeIterEnd_;
//
//    public:
//        EdgeTypeIterator(
//            const EdgeTypeDataType& edgeType)
//                : edgeTypeIter_   ( edgeType.cbegin()),
//                 kEdgeTypeIterEnd_( edgeType.cend  ()){
//            return;
//        }
//
//        inline const EdgeType& operator*() const{
//            return *this->edgeTypeIter_->first;
//        }
//
//        inline bool IsDone() const{
//            return this-> edgeTypeIter_
//                == this->kEdgeTypeIterEnd_;
//        }
//
//        inline void ToNext(){
//            assert(!this->IsDone());
//            this->edgeTypeIter_++;
//            return;
//        }
//    };
//
//    template<enum class EdgeDirect direct,
//             typename std::enable_if<direct == EdgeDirect::InOut
//                                  || direct == EdgeDirect::OutIn,int>::type=0>
//    class VertexIterator{
//    private:
//              VertexesContainerType::const_iterator                 vertexesIter_;
//              EdgeTypeContainerType::const_iterator   firstDirectionEdgeTypeIter_;
//              EdgeTypeContainerType::const_iterator  secondDirectionEdgeTypeIter_;
//        const EdgeTypeContainerType::const_iterator  kFirstDirectionEdgeTypeIterEnd_;
//        const EdgeTypeContainerType::const_iterator kSecondDirectionEdgeTypeIterEnd_;
//
//        bool inFirstDirectionEdgeType_;
//
//        inline void InitializeIters(
//                        const EdgeTypeDataType&  firstDirectionEdgeType,
//                        const EdgeTypeDataType& secondDirectionEdgeType){
//            if (firstDirectionEdgeType.cbegin()
//             != firstDirectionEdgeType.cend  ()){
//                /// this vertex have edges in first direction
//                /// if there is a type of edge, then it must be not empty
//                assert(this-> firstDirectionEdgeTypeIter_->cbegin()
//                    != this-> firstDirectionEdgeTypeIter_->  cend());
//                this->vertexesIter_
//                    = this->firstDirectionEdgeTypeIter_->cbegin();
//                /// marks that is visiting input edges
//                this->inFirstDirectionEdgeType_ = true;
//                return;
//            }
//            if (secondDirectionEdgeType.cbegin()
//             != secondDirectionEdgeType.cend  ()){
//                /// this vertex have edges in second direction
//                /// if there is a type of edge, then it must be not empty
//                assert(this->secondDirectionEdgeTypeIter_.cbegin()
//                    != this->secondDirectionEdgeTypeIter_.  cend());
//                this->vertexesIter_
//                    = this->secondDirectionEdgeTypeIter_->cbegin();
//                /// marks that is visiting output edges
//                this->inFirstDirectionEdgeType_ = false;
//            }
//            /// this vertex is an isolated node
//            assert(HasIsolatedVertex);
//            /// ToDo by Wenzhi:
//            ///     add a proporal initialization here for this->vertexesIter_;
//            this->inFirstDirectionEdgeType_ = true;
//            return;
//        }
//
//    public:
//        template<typename std::enable_if<direct == EdgeDirect::InOut>::type>
//        VertexIterator(const EdgeTypeDataType&  firstDirectionEdgeType,
//                       const EdgeTypeDataType& secondDirectionEdgeType)
//              :firstDirectionEdgeTypeIter_   (  firstDirectionEdgeType.cbegin()),
//              secondDirectionEdgeTypeIter_   ( secondDirectionEdgeType.cbegin()),
//              kFirstDirectionEdgeTypeIterEnd_(  firstDirectionEdgeType.  cend()),
//             kSecondDirectionEdgeTypeIterEnd_( secondDirectionEdgeType.  cend()){
//            this->InitializeIters( firstDirectionEdgeType,
//                                  secondDirectionEdgeType);
//            return;
//        }
//
//        inline bool IsDone() const{
//            /// it is visiting output edge but outEdge iterator meets end
//            return (!this->inFirstDirectionEdgeType_)
//                 &&( this-> secondDirectionEdgeTypeIter_
//                 ==  this->kSecondDirectionEdgeTypeIterEnd_);
//        }
//
//        inline const Vertex* operator*(){
//            assert(!this->IsDone());
//            return *(this->vertexesIter_);
//        }
//
//        inline void ToNext(){
//            /// to simplify the following codes
//                  EdgeTypeContainerType::const_iterator& edgeTypeIter
//                            = this->inFirstDirectionEdgeType_?
//                              this->  firstDirectionEdgeTypeIter_:
//                              this-> secondDirectionEdgeTypeIter_;
//            const EdgeTypeContainerType::const_iterator& edgeTypeIterEnd
//                            = this->inFirstDirectionEdgeType_?
//                              this-> kFirstDirectionEdgeTypeIterEnd_:
//                              this->kSecondDirectionEdgeTypeIterEnd_;
//            assert(!this->IsDone());
//            this->vertexesIter_++;/// the next vertex in this type of edge
//            if (this->vertexesIter_ != edgeTypeIter.cend()){
//                /// has not visited all vertex in
//                /// this type of edge on this direction
//                return;
//            }
//            /// has visited all vertex in this type of edge on this direction
//            edgeTypeIter++;/// change to another type
//            if (edgeTypeIter == edgeTypeIterEnd){
//                /// has visited all types of edge in this direction
//                if (this->IsDone())
//                    return;/// has visited all edges
//                /// now visiting first direction edge
//                assert(this->inFirstDirectionEdgeType_);
//                this->inFirstDirectionEdgeType_ = false;
//                if (this->IsDone()){
//                    /// there are no output edges in this case
//                    assert(this-> secondDirectionEdgeTypeIter_
//                        == this->kSecondDirectionEdgeTypeIterEnd_);
//                    return;
//                }
//                /// if there is a type of edge, then it must be not empty
//                assert(this->secondDirectionEdgeTypeIter_->cbegin()
//                    != this->secondDirectionEdgeTypeIter_->  cend());
//                /// begins to visit output edge
//                this->vertexesIter_
//                     = this->secondDirectionEdgeTypeIter_->cbegin();
//                return;
//            }
//            /// has not visited all types of edge in this direction
//            /// if there is a type of edge, then it must be not empty
//            assert(edgeTypeIter.cbegin() != edgeTypeIter.cend());
//            /// begins to visit the next type of edges
//            this->vertexesIter_ = edgeTypeIter.cbegin();
//            return;
//        }
//    };

#endif // _VERTEX_HPP
